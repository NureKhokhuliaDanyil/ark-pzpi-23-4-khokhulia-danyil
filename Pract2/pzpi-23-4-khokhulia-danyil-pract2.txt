МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ
 
ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ
УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ
 
Кафедра «Програмна інженерія»
 
 
ЗВІТ
до практичного заняття №2 з дисципліни
«Аналіз та рефакторинг коду»
На тему: «Методи рефакторингу коду програмного забезпечення»

 
Виконав:                                                   Прийняв:
ст. гр. ПЗПІ-23-4                                    	   ст. викладач кафедри ПІ 
Хохуля Даниіл Андрійович                                   Сокорчук Ігор Петрович
						

Харків 2025

1 МЕТА
     Навчити студентів основним методам рефакторингу коду на основі реальних прикладів з їхніх власних програмних проєктів. Студенти повинні навчитися ідентифікувати проблеми в коді та використовувати відповідні методи рефакторингу для покращення його якості.

2 ЗАВДАННЯ
	Студент повинен обрати три методи рефакторингу коду із книги Мартіна Фаулера «Refactoring. Improving the Design of Existing Code».
Навести приклади свого особистого коду (з курсових, лабораторних або інших проєктів), який потребує покращення, та продемонструвати застосування обраних методів.
Кожен метод рефакторингу повинен супроводжуватись:
1. Описом проблеми, яку вирішує даний метод.
2. Кодом до і після застосування методу рефакторингу.
3. Поясненням переваг використаного методу.

3 ОПИС ВИКОНАНОЇ РОБОТИ
     Під час виконання практичного завдання було детально опрацьовано тему рефакторингу програмного коду на прикладі проєкту CryptexAPI, який було представлено в якості курсового проекту за другий курс навчання, реалізованого мовою C#. Робота розпочалася з аналізу поточної архітектури REST API та визначення основної мети дослідження — покращення структури, читабельності та супровідності коду шляхом застосування перевірених технік рефакторингу.
     Далі було розглянуто загальні принципи "чистого коду" та обрано три ключові методи для оптимізації: Extract Method (Виділення методу), Move Method (Переміщення методу) та Replace Temp with Query (Заміна тимчасової змінної запитом). Для кожного з них було проаналізовано проблемні ділянки коду, що порушували принципи SOLID або DRY.
     Першим кроком було проведено детальний аналіз застосування методу Extract Method у класі UserService. У початковому варіанті методи, що відповідають за операції з активами (купівля, продаж, конвертація), містили дубльовані блоки коду для пошуку та валідації монет у гаманці користувача. Це ускладнювало внесення змін та збільшувало ризик помилок. Після рефакторингу повторювану логіку було винесено в окремий приватний метод, що дозволило зробити основні методи лаконічними та сфокусованими виключно на бізнес-процесах.
     Наступним етапом стало застосування методу Move Method для усунення проблеми «заздрості до функціоналу» (Feature Envy) у сервісі FuethersDealService. Було виявлено, що метод розрахунку прибутку (PnL) знаходився у сервісному шарі, хоча використовував виключно дані сутності угоди. Це призводило до розмивання відповідальності та створення «анемічної» моделі даних. У процесі рефакторингу логіку розрахунку було переміщено безпосередньо в клас сутності FuethersDeal, що підвищило зв’язність коду та наблизило архітектуру до принципів об'єктно-орієнтованого проєктування.
     Також було розглянуто приклад застосування техніки Replace Temp with Query у класі WalletService. У вихідному коді методу генерації seed-фрази використовувалася громіздка тимчасова змінна, що містила великий список слів, візуально перевантажуючи алгоритм. Після оптимізації ініціалізацію списку було винесено в окремий метод-запит. Це дозволило відокремити статичні дані від логіки генерації, зробивши код чистим, зрозумілим та легшим для майбутнього розширення чи заміни джерела даних.
     Наприкінці роботи було сформовано висновки щодо впливу проведених змін на якість проєкту. Було зазначено, що застосування обраних методів рефакторингу дозволило усунути дублювання, покращити розподіл відповідальності між класами та спростити підтримку системи, не змінюючи її зовнішньої поведінки.
     
4 ВИСНОВКИ
     Під час виконання даної практичної роботи я досяг основної мети заняття — навчився ідентифікувати проблемні ділянки у власному коді та застосовувати відповідні методи рефакторингу для покращення його якості. На основі реального проєкту CryptexAPI було проаналізовано архітектурні недоліки та практично застосовано три ключові техніки: Extract Method, Move Method та Replace Temp with Query.
     У ході роботи вдалося значно оптимізувати структуру сервісів, усунути дублювання коду в логіці валідації та виправити проблему неправильного розподілу відповідальності між класами («Feature Envy»). Це наочно продемонструвало, що систематичний рефакторинг дозволяє трансформувати складний для сприйняття код у гнучку систему, яку значно легше читати, тестувати та розширювати новим функціоналом. Здобуті навички є фундаментом для підтримки високої культури коду в професійній розробці програмного забезпечення.
     
5 ВИКОРИСТАНІ ДЖЕРЕЛА

1. Martin R. C. Clean Code: A Handbook of Agile Software Craftsmanship. Prentice Hall, 2008. 464 p. URL: https://www.oreilly.com/library/view/clean-code/9780136083238/ (дата звернення: 1.12.2025).
2. Fowler M. Refactoring: Improving the Design of Existing Code. Addison-Wesley Professional, 2018. 448 p. URL: https://martinfowler.com/books/refactoring.html (дата звернення: 2.12.2025).
3. C# Coding Conventions. Microsoft Learn: Build skills that open doors in your career. URL: https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/coding-style/coding-conventions (дата звернення: 2.12.2025).
4. Refactoring in Visual Studio. Microsoft Learn. URL: https://learn.microsoft.com/en-us/visualstudio/ide/refactoring-in-visual-studio?view=visualstudio (дата звернення: 1.12.2025).
5. Refactoring and Design Patterns. Refactoring.Guru. URL: https://refactoring.guru/refactoring (дата звернення: 2.12.2025).
6. McConnell S. Code Complete. Microsoft Press, 2004. 960 p. URL: https://www.oreilly.com/library/view/code-complete-second/0735619670/ (дата звернення: 3.12.2025).
     
ДОДАТОК А
Відеозапис презентації результатів практичної роботи: https://youtu.be/fCPWFHULvpY
Хронологічний опис відеозапису: 
00:00 - Вступ 
1:18 - Extract Method 
2:13 - Rename Method 
3:55 - Simplify Conditional Expressions 
4:48 - Рефакторинг курсового проекту CryptexApi 
5:37 - Приклад Extract Method 
5:32 - Приклад Move Method 
6:36 - Приклад Replace Temp with Query 
8:06 - Алгоритм проведення рефакторингу 
9:23 - Інстументи для автоматизації рефакторингу 
10:43 - Висновки

ДОДАТОК Б
Програмний код, використаний як приклад у презентації.
UserService.cs
До рефакторингу:
public async Task BuyCoin(int id, NameOfCoin coin, double amount)
{
    try
    {
        var user = await GetUserByIdAsync(id);
        // Дублювання логіки пошуку та валідації
        var coinInWallet = user.Wallet.AmountOfCoins.FirstOrDefault(c => c.Name == coin);

        if (coinInWallet == null)
        {
            throw new EntityNotFoundException($"Coin {coin} not found in user's wallet");
        }

        var currentPrice = coinInWallet.Price;
        // ... подальша логіка купівлі ...
    }
    catch (Exception)
    {
        throw;
    }
}
Після рефаторингу:
public async Task BuyCoin(int id, NameOfCoin coin, double amount)
{
    try
    {
        var user = await GetUserByIdAsync(id);
        // Виклик виділеного методу
        var coinInWallet = GetCoinFromUserOrThrow(user, coin);

        var currentPrice = coinInWallet.Price;
        // ... подальша логіка купівлі ...
    }
    catch (Exception)
    {
        throw;
    }
}
Після рефаторингу (логіка переміщенна в FuethersDeal.cs):
// Новий приватний метод, що містить логіку пошуку
private Coin GetCoinFromUserOrThrow(User user, NameOfCoin coinName)
{
    var coin = user.Wallet.AmountOfCoins.FirstOrDefault(c => c.Name == coinName);
    if (coin == null)
    {
        throw new EntityNotFoundException($"Coin {coinName} not found in user's wallet");
    }
    return coin;
}


FuethersDealService.cs
До рефакторингу:
// У класі FuethersDealService.cs
private double CalculatePnl(FuethersDeal deal, double currentPrice)
{
    if (deal.TypeOfDeal == TypeOfFuetersDeal.Long)
    {
        return (currentPrice - deal.EnterPrice) * deal.Amount * deal.Leverage;
    }
    else
    {
        return (deal.EnterPrice - currentPrice) * deal.Amount * deal.Leverage;
    }
}

public class FuethersDeal
{
    // ... властивості ...
    public double EnterPrice { get; set; }
    public double Amount { get; set; }
    public int Leverage { get; set; }
    public TypeOfFuetersDeal TypeOfDeal { get; set; }

    // Метод переміщено сюди
    public double CalculatePnl(double currentPrice)
    {
        if (TypeOfDeal == TypeOfFuetersDeal.Long)
        {
            return (currentPrice - EnterPrice) * Amount * Leverage;
        }
        else
        {
            return (EnterPrice - currentPrice) * Amount * Leverage;
        }
    }
}

WalletService.cs     
До рефакторингу:
private SeedPhrase CreateSeedPhrase()
{
    try
    {
        // Громіздка змінна захаращує метод
        var words = new List<string>
        {
            "umbrella", "window", "elephant", "chair", "spaghetti", "notebook", 
            "clover", "ocean", "aardvark", "chocolate", "eyebrow", "pigeon", 
            // ... ще 50+ слів ...
            "kaleidoscope", "lemon"
        };

        var random = new Random();
        // ... логіка генерації ...
    }
    catch (Exception ex)
    {
        throw new Exception($"Failed to create seed phrase {ex.Message}");
    }
}  
Після рефаторингу:
private SeedPhrase CreateSeedPhrase()
{
    try
    {
        var words = GetSeedWords(); // Код став чистим

        var random = new Random();
        var seedPhrase = new SeedPhrase
        {
            SeedPhraseValues = new List<string>()
        };

        for (var i = 0; i < GlobalConsts.SeedPhraseLength; i++)
        {
            var randomWord = words[random.Next(words.Count)];
            seedPhrase.SeedPhraseValues.Add(randomWord);
        }
        return seedPhrase;
    }
    catch (Exception ex)
    {
        throw new Exception($"Failed to create seed phrase {ex.Message}");
    }
}

// Винесений метод-запит
private List<string> GetSeedWords()
{
    return new List<string>
    {
        "umbrella", "window", "elephant", "chair", "spaghetti", "notebook",
        "clover", "ocean", "aardvark", "chocolate", "eyebrow", "pigeon",
        // ... повний список слів ...
        "kaleidoscope", "lemon"
    };
}

ДОДАТОК В
Презентація на тему «Правила оформлення програмного коду».